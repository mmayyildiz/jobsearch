"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const util = __importStar(require("util"));
const chalk_1 = __importDefault(require("chalk"));
const chokidar = __importStar(require("chokidar"));
const glob_1 = __importDefault(require("glob"));
const dts_creator_1 = require("./dts-creator");
const glob = util.promisify(glob_1.default);
function run(searchDir, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const filesPattern = path.join(searchDir, options.pattern || '**/*.css');
        const creator = new dts_creator_1.DtsCreator({
            rootDir: process.cwd(),
            searchDir,
            outDir: options.outDir,
            camelCase: options.camelCase,
            dropExtension: options.dropExtension,
        });
        const writeFile = (f) => __awaiter(this, void 0, void 0, function* () {
            try {
                const content = yield creator.create(f, undefined, !!options.watch);
                yield content.writeFile();
                if (!options.silent) {
                    console.log('Wrote ' + chalk_1.default.green(content.outputFilePath));
                }
            }
            catch (error) {
                console.error(chalk_1.default.red('[Error] ' + error));
            }
        });
        if (!options.watch) {
            const files = yield glob(filesPattern);
            yield Promise.all(files.map(writeFile));
        }
        else {
            console.log('Watch ' + filesPattern + '...');
            const watcher = chokidar.watch([filesPattern.replace(/\\/g, "/")]);
            watcher.on('add', writeFile);
            watcher.on('change', writeFile);
            yield waitForever();
        }
    });
}
exports.run = run;
function waitForever() {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(() => { });
    });
}
//# sourceMappingURL=run.js.map